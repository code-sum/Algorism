# 📌 2022-07-27 BOJ 풀이



#### 1157. 단어 공부 [(link)](https://www.acmicpc.net/problem/1157)

> 알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.

```python
# 변수.upper() = 변수에 있는 영어 소문자를 전부 대문자로 바꿈
word = input().upper()

# 주어진 word 에서 중복 값을 전부 제거하여 새로운 변수를 만듬
unique_word = list(set(word))

cnt_list = []
for i in unique_word:

    # A변수.count(B변수) = A변수에서 B변수 갯수를 세어라
    cnt = word.count(i)
    cnt_list.append(cnt)

# 가장 많이 사용된 알파벳이 여러 개면 "?" 출력
if cnt_list.count(max(cnt_list)) > 1:
    print("?")
else:
    max_index = cnt_list.index(max(cnt_list))
    print(unique_word[max_index])
```



#### 2511. 카드놀이 [(link)](https://www.acmicpc.net/problem/2511)

> 0부터 9까지의 숫자가 표시된 카드를 가지고 두 사람 A와 B가 게임을 한다. A와 B에게는 각각 0에서 9까지의 숫자가 하나씩 표시된 10장의 카드뭉치가 주어진다. 두 사람은 카드를 임의의 순서로 섞은 후 숫자가 보이지 않게 일렬로 늘어  놓고 게임을 시작한다. 단, 게임 도중 카드의 순서를 바꿀 수는 없다.
>
> A와 B 각각이 늘어놓은 카드를 뒤집어서 표시된 숫자를 확인하는 것을 한 라운드라고 한다. 게임은 첫 번째 놓인 카드부터 시작하여 순서대로 10번의 라운드로 진행된다. 각 라운드에서는 공개된 숫자가 더 큰 사람이 승자가 된다. 승자에게는 승점 3점이 주어지고 패자에게는 승점이 주어지지 않는다. 만약 공개된 두 숫자가 같아서 비기게 되면, A, B 모두에게 승점 1점이 주어진다. 
>
> 10번의 라운드가 모두 진행된 후, 총 승점이 큰 사람이 게임의 승자가 된다. 만약, A와 B의 총 승점이 같은 경우에는, 제일 마지막에 이긴 사람을 게임의 승자로 정한다. 그래도 승부가 나지 않는 경우는 모든 라운드에서 비기는 경우뿐이고 이 경우에 두 사람은 비겼다고 한다.
>
> 예를 들어, 다음 표에서 3번째 줄은 각 라운드의 승자를 표시하고 있다. 표에서 D는 무승부를 나타낸다. 이 경우에 A의 총 승점은 16점이고, B는 13점이어서, A가 게임의 승자가 된다. 
>
> | 라운드 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
> | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> | A      | 4    | 5    | 6    | 7    | 0    | 1    | 2    | 3    | 9    | 8    |
> | B      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 0    |
> | 승     | A    | A    | A    | A    | B    | B    | B    | B    | D    | A    |
>
> 아래 표의 경우에는 A와 B의 총 승점은 13점으로 같다. 마지막으로 승부가 난 라운드는 7번째 라운드이고, 이 라운드의 승자인 B가 게임의 승자가 된다. 
>
> | 라운드 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
> | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> | A      | 9    | 1    | 7    | 2    | 6    | 3    | 0    | 4    | 8    | 5    |
> | B      | 6    | 3    | 9    | 2    | 1    | 0    | 7    | 4    | 8    | 5    |
> | 승     | A    | B    | B    | D    | A    | A    | B    | D    | D    | D    |
>
> A와 B가 늘어놓은 카드의 숫자가 순서대로 주어질 때, 게임의 승자가 A인지 B인지, 또는 비겼는지 결정하는 프로그램을 작성하시오.

```python
import sys
sys.stdin = open("2511.txt")

# 승자는 각 라운드당 +3 승점
# 패자에게는 승점 없음
# 비길 경우 두 사람에게 +1 승점
# 라운드 종료 후 총점이 큰 사람이 승자
# 승점이 같으면 마지막에 이긴 사람이 승자

a = list(map(int, input().split()))
b = list(map(int, input().split()))

a_cnt = 0; b_cnt = 0
record = [0 for i in range(10)]

for i in range(10):
    if a[i] > b[i]:
        a_cnt += 3; record[i] = "A"
    elif a[i] < b[i]:
        b_cnt += 3; record[i] = "B"
    else:
        a_cnt += 1; b_cnt += 1; record[i] = "D"

# A점수가 더 높을 경우 출력
if a_cnt > b_cnt:
    print(a_cnt, b_cnt)
    print("A")

# B점수가 더 높을 경우 출력
if a_cnt < b_cnt:
    print(a_cnt, b_cnt)
    print("B")

# A와 B 총점이 동점일 경우 출력
if a_cnt == b_cnt:
    if a == b:
        print(a_cnt, b_cnt)
        print("D")
    else:
        print(a_cnt, b_cnt)
        for i in reversed(range(10)):
            if record[i] == "A":
                print("A"); break
            elif record[i] == "B":
                print("B"); break
```



#### 2711. 오타맨 고창영 [(link)](https://www.acmicpc.net/problem/2711)

> 고창영은 맨날 오타를 낸다. 창영이가 오타를 낸 문장과 오타를 낸 위치가 주어졌을 때, 오타를 지운 문자열을 출력하는 프로그램을 작성하시오.
>
> 창영이는 오타를 반드시 1개만 낸다.

```python
import sys
sys.stdin = open("2711.txt")

t = int(input())

for i in range(1, t+1):
    tc = list(input().split())
    # print(*tc)

    spot = int(tc[0])-1
    word = list(tc[1])
    
    for j in range(len(word)):
        if j == spot:
            del word[j]
    
    print(*word, sep='')
```



#### 2789. 유학금지 [(link)](https://www.acmicpc.net/problem/2789)

> 아주 멀리 떨어져 있는 작은 나라가 있다. 이 나라에서 가장 공부를 잘하는 학생들은 모두 다른 나라로 유학을 간다. 정부는 최고의 학생들이 자꾸 유학을 가는 이유를 찾으려고 했다. 하지만, 학생들의 이유가 모두 달랐기 때문에 정확한 이유를 찾을 수 없었다. 정부의 고위직은 뛰어난 학생들이 자꾸 유학을 가는 현상을 매우 불쾌해 했다.
>
> 가장 많은 학생들이 유학을 가는 대학교는 영국의 캠브리지 대학교이다. 정부는 인터넷 검열을 통해서 해외로 나가는 이메일의 내용 중 일부를 삭제하기로 했다. 이메일의 각 단어 중에서 CAMBRIDGE에 포함된 알파벳은 모두 지우기로 했다. 즉, 어떤 이메일에 LOVA란 단어가 있다면, A는 CAMBRIDGE에 포함된 알파벳이기 때문에, 받아보는 사람은 LOV로 받는다.
>
> 이렇게, 어떤 단어가 주어졌을 때, 검열을 거친 후에는 어떤 단어가 되는지 구하는 프로그램을 작성하시오.

```python
word = input()

ans = []
for i in word:
    if i not in 'CAMBRIDGE':
        ans.append(i)

print(*ans, sep='')
```



#### 2851. 슈퍼 마리오 [(link)](https://www.acmicpc.net/problem/2851)

> 슈퍼 마리오 앞에 10개의 버섯이 일렬로 놓여져 있다. 이 버섯을 먹으면 점수를 받는다.
>
> 슈퍼 마리오는 버섯을 처음부터 나온 순서대로 집으려고 한다. 하지만, 모든 버섯을 집을 필요는 없고 중간에 중단할 수 있다. 중간에 버섯을 먹는 것을 중단했다면, 그 이후에 나온 버섯은 모두 먹을 수 없다. 따라서 첫 버섯을 먹지 않았다면, 그 이후 버섯도 모두 먹을 수 없다.
>
> 마리오는 받은 점수의 합을 최대한 100에 가깝게 만들려고 한다.
>
> 버섯의 점수가 주어졌을 때, 마리오가 받는 점수를 출력하는 프로그램을 작성하시오.

```python
# 먹은 버섯 리스트
eaten = []

# 데이터 입력
for i in range(10):
    point = int(input())
    eaten.append(point)

# 먹은 점수의 초기값
score = 0

for j in eaten:
    score += j
    if score >= 100:
        if score - 100 > 100 - (score - j):
            score -= j
        break

print(score)
```



#### 2920. 음계 [(link)](https://www.acmicpc.net/problem/2920)

> 다장조는 c d e f g a b C, 총 8개 음으로 이루어져있다. 이 문제에서 8개 음은 다음과 같이 숫자로 바꾸어 표현한다. c는 1로, d는 2로, ..., C를 8로 바꾼다.
>
> 1부터 8까지 차례대로 연주한다면 ascending, 8부터 1까지 차례대로 연주한다면 descending, 둘 다 아니라면 mixed 이다.
>
> 연주한 순서가 주어졌을 때, 이것이 ascending인지, descending인지, 아니면 mixed인지 판별하는 프로그램을 작성하시오.

```python
import sys
sys.stdin = open("2920.txt")

input_ = input()

if input_ == "1 2 3 4 5 6 7 8":
    print("ascending")
elif input_ == "8 7 6 5 4 3 2 1":
    print("descending")
else:
    print("mixed")
```



#### 2941. 크로아티아 알파벳 [(link)](https://www.acmicpc.net/problem/2941)

> 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.
>
> | 크로아티아 알파벳 | 변경 |
> | ----------------- | ---- |
> | č                 | c=   |
> | ć                 | c-   |
> | dž                | dz=  |
> | đ                 | d-   |
> | lj                | lj   |
> | nj                | nj   |
> | š                 | s=   |
> | ž                 | z=   |
>
> 예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.
>
> dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.

```python
croatia = ['c=', 'c-', 'dz=', 'd-', 'lj', 'nj', 's=', 'z=']
word = input()

for i in croatia:
    word = word.replace(i, '*')

print(len(word))
```



#### 4673. 셀프넘버 [(link)](https://www.acmicpc.net/problem/4673)

> 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.
>
> 양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다. 
>
> 예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.
>
> 33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...
>
> n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 
>
> 생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97
>
> 10000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.

```python
# for i in range(1, 10001):
#     생성자(i) = 
#     셀프넘버(i) = 생성자가 없는 수
#     print(셀프넘버)

def d(n):
    n = n + sum(map(int, str(n)))
    return n

not_self_num = set()
for i in range(1, 10001):
    not_self_num.add(d(i))

for j in range(1, 10001):
    if j not in not_self_num:
        print(j)
```



#### 7568. 덩치 [(link)](https://www.acmicpc.net/problem/7568)

> 우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x > p 그리고 y > q 이라면 우리는 A의 덩치가 B의 덩치보다 "더 크다"고 말한다. 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다. 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, "덩치"로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.
>
> N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 "큰 덩치"의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.
>
> | 이름 | (몸무게, 키) | 덩치 등수 |
> | :--: | :----------: | :-------: |
> |  A   |  (55, 185)   |     2     |
> |  B   |  (58, 183)   |     2     |
> |  C   |  (88, 186)   |     1     |
> |  D   |  (60, 175)   |     2     |
> |  E   |  (46, 155)   |     5     |
>
> 위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다. 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.

```python
# 첫 줄에 전체 사람의 수 N이 주어짐
N = int(input())

# 덩치 등수를 담을 리스트 컨테이너 생성
result = []

# 각 학생에 대한 정보를 담을 리스트 컨테이너 생성
data = []

# 그리고 이어지는 N개의 줄에 각 사람의 몸무게, 키를
# 나타내는 양의 정수 x, y가 하나의 공백을 두고 각각 나타남

# Step 1.
for i in range(N):
    x, y = map(int, input().split())
    data.append((x, y))    # data.append(x, y) 아님에 유의!
    # print(data)

# Step 2.
for i in range(N):
    count = 0
    for j in range(N):    # i번째 학생과 j 학생의 [몸무게 and 키] 모두를 비교!
        if data[i][0] < data[j][0] and data[i][1] < data[j][1]:
            count += 1          # i번째 학생보다 j번째 학생이 덩치크면 count + 1 !
                                # i번째 학생보다 덩치 큰 j번째 학생들이 많으면 그만큼 count +1 횟수도 증가
    result.append(count + 1)    # 덩치 등수(0+1+1...)들을 result 리스트에 append

for k in result:
    print(k, end = " ")   # 학생 N명의 덩치 등수를 '공백 문자로 분리해서' 출력
```



#### 10798. 세로읽기 [(link)](https://www.acmicpc.net/problem/10798)

> 아직 글을 모르는 영석이가 벽에 걸린 칠판에 자석이 붙어있는 글자들을 붙이는 장난감을 가지고 놀고 있다. 
>
> 이 장난감에 있는 글자들은 영어 대문자 ‘A’부터 ‘Z’, 영어 소문자 ‘a’부터 ‘z’, 숫자 ‘0’부터 ‘9’이다. 영석이는 칠판에 글자들을 수평으로 일렬로 붙여서 단어를 만든다. 다시 그 아래쪽에 글자들을 붙여서 또 다른 단어를 만든다. 이런 식으로 다섯 개의 단어를 만든다. 아래 그림 1은 영석이가 칠판에 붙여 만든 단어들의 예이다. 
>
> ```
> A A B C D D
> a f z z 
> 0 9 1 2 1
> a 8 E W g 6
> P 5 h 3 k x
> ```
>
> <그림 1>
>
> 한 줄의 단어는 글자들을 빈칸 없이 연속으로 나열해서 최대 15개의 글자들로 이루어진다. 또한 만들어진 다섯 개의 단어들의 글자 개수는 서로 다를 수 있다. 
>
> 심심해진 영석이는 칠판에 만들어진 다섯 개의 단어를 세로로 읽으려 한다. 세로로 읽을 때, 각 단어의 첫 번째 글자들을 위에서 아래로 세로로 읽는다. 다음에 두 번째 글자들을 세로로 읽는다. 이런 식으로 왼쪽에서 오른쪽으로 한 자리씩 이동 하면서 동일한 자리의 글자들을 세로로 읽어 나간다. 위의 그림 1의 다섯 번째 자리를 보면 두 번째 줄의 다섯 번째 자리의 글자는 없다. 이런 경우처럼 세로로 읽을 때 해당 자리의 글자가 없으면, 읽지 않고 그 다음 글자를 계속 읽는다. 그림 1의 다섯 번째 자리를 세로로 읽으면 D1gk로 읽는다. 
>
> 그림 1에서 영석이가 세로로 읽은 순서대로 글자들을 공백 없이 출력하면 다음과 같다:
>
> Aa0aPAf985Bz1EhCz2W3D1gkD6x
>
> 칠판에 붙여진 단어들이 주어질 때, 영석이가 세로로 읽은 순서대로 글자들을 출력하는 프로그램을 작성하시오.

```python
import sys
sys.stdin = open("10798.txt")

# 매트릭스 세로 탐색해서
# 나오는 요소들을 빈 리스트에 붙이기
# if 매트릭스 요소가 공백(*)이면:
# continue

ans = [["*"]*15 for i in range(5)]
for i in range(5):
    a = list(input())
    a_len = len(a)

    for j in range(a_len):
        ans[i][j] = a[j]

# 세로 탐색
for i in range(15):
    for j in range(5):
        if ans[j][i] == "*":
            continue
        else:
            print(ans[j][i], end='')
```



#### 17249. 태보태보 총난타 [(link)](https://www.acmicpc.net/problem/17249)

> 태보(TaeBo)란, 태권도와 복싱을 조합한 운동이다. 복싱의 공격 기술로는 민첩하게 앞주먹을 뻗으면서 가볍게 치는 잽, 옆으로 치는 펀치인 훅이 있다.
>
> 선풍적인 인기에 태보 강의를 들으며 태보를 마스터한 혜정이는 이제 펀치 속도가 워낙 빨라서 잽과 훅을 반복하다보면 잔상이 남는다.
>
> 얼굴의 왼편에 왼손의 잔상이, 오른편에는 오른손이 잔상이 남을 때 혜정이는 주먹을 몇 번 뻗었을까?
>
> 주먹의 잔상은 =로 시작하여 @로 끝나고, 잔상이 남지 않는 경우는 없다. 얼굴 형태가 (^0^) 꼴이고, 주먹의 잔상이 같은 곳에 위치하지 않는다.

```python
hook = input()

cnt = 0
ans = []

for i in hook:
    if i == "@":
        cnt += 1
    elif i == "=":
        continue
    elif i == "(":
        ans.append(cnt)
        cnt = 0
    elif i == "^" and i == "0" and i == ")":
        continue

ans.append(cnt)

print(*ans)
```

